# 基本概念

- 深度：从根节点到叶节点的node数量，跟节点的深度是1 （二叉树第n层深度有2^n-1^个节点）
- 高度：从叶节点到跟节点的edge数量，叶节点的高度是0
- 注意有相同深度的节点，他们的高度不一定相同，分取决于他们自己子树的深度
- 森林：由不相交的多棵树组成



# 二叉树

## 二叉搜索树

Binary search tree

BST的中序遍历是有序的

如果左子树不为空，左子树的所有节点值都小于根节点值

如果右子树不为空，右子树的所有节点值都大于根节点值



## AVL树

**平衡二叉树**

AVL树中任意节点的左右子树高度相差只能是-1或0或1

有四种平衡调整：LL, RR, LR, RL

由于过于严格，实际操作中会浪费系统资源来反复平衡树，一般不用。



## 红黑树

**非严格平衡二叉**树

变换规则的图像拆解见算法导论

- 红黑树规则
  1. 每一个节点不是黑就是红
  2. 红色节点不能相连
  3. 根节点都是黑色（叶节点也都是黑色，不过这层叶节点有时候不画出来）
  4. 红节点的两个子节点都是黑色
- 变换规则
  1. 变色
     - 条件：当前节点红色，父节点叔节点红色
     - 操作：父节点叔节点变黑，祖父节点变红，**把指针指向祖父节点**（以祖父节点作为当前节点继续检查是否符合红黑树规则）
  2. 左旋
     - 条件：当前节点红色，父节点红色，叔节点黑色，当前节点是**右子树**
     - 操作：父节点为根左旋，**把指针指向左子节点**（左旋之前是父节点）
  3. 右旋
     - 条件：当前节点红色，父节点红色，叔节点黑色，当前节点是**左子树**
     - 操作：父节点变黑，祖父节点变红，祖父节点为根右旋
- 操作：每次插入新节点都标为红色

- 局限：
  - 红黑树适合应用在内存中（比如HashMap，嵌入式），内存的高速可以支撑红黑树的深度。
  - 由于二叉树过深的深度，在大数据上红黑树效率过低。
  - 因为IO浪费与读取资源浪费（具体的解释看算法导论B树和计算机组成原理），红黑树也不适合磁盘存储。



## 伸展树

Splay tree

在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方，目的是提升高频节点的查询速度。





## 哈夫曼树

Huffman tree，前缀树

将不同类型的object转化成为0与1组成的byte type

应用：

- 压缩：byte是空间最小的type
- 加密：使用不同的权重组，得到的树结构就完全不同，用不同的树来解码就会得到不同信息



# 多叉树

## B树

**平衡多叉树**

**m阶**B树规则：

1. 每个节点的key保持non-descending order，key就是子节点的分隔点，所以**每个节点的key比子节点少一个**
2. 每个节点**至少**有$\lceil m/2 \rceil$个子节点（除了根节点）
3. 每个节点**至多**有m个子节点
4. 所有叶节点的深度相同，即B树的高度
5. 所有叶节点没有任何key，是指向磁盘页面的指针

==B系列树的插入操作与其他树不同，是从最底层，也就是叶节点那一层插入，把底层的key向上挤。==

B树的**分支因子**取决于 key值相对于磁盘一个页面(page)的大小（一个节点通常与一个完整磁盘页一样大，目的是一次刚好能全部拿出一个页面里存的所有记录）

包含n个key的B树的最大高度: $h_{max} = 1 + log_{\lceil m/2 \rceil}((n+1)/2)$，其中$(n+1)/2$是算叶节点数量，这个式子跟计算二叉树最大高度的原理完全一样。



红黑树为什么不适合用作数据库索引？

- 数据库肯定不在内存上（Redis在吗？），用二叉树会有IO浪费和读取资源浪费，多叉树的节点可以直接取到一整个磁盘页
- 红黑树是二叉树，在处理大量数据的时候依然会深度过深，降低效率。B树是多叉树，显著降低深度。
- 但其实B树也不够好，如果有中间节点信息丢失，会导致无法访问其下层的子节点，B+树才是数据库的索引



## B+树

与B树的区别：

1. 每个节点的 key数量==子节点数量
2. 上一层的key就是其对应的子节点的最大（或最小）key的复写，所以其实叶节点层就完整地储存了所有的key
3. 数据只存在叶节点层，这一层同时也是双向链表



最适合大数据的磁盘存储，用于**MySQL索引**。

只在叶节点存记录，所有非叶节点都只是索引，丢失上层索引不会丢失底层记录，保证系统稳定性。这也意味着B+树的查找操作一定会从根节点走到叶节点（全高度），一定不会像B树一样提前结束。

所有叶节点有序，并形成双向链表（方便求连续范围的query，比如`SELECT id FROM user WHERE id < 10;`，可以使用链表从10快速找出一组记录，而不用1-10单独从树顶查询），B+树加双向链表是一个很像**跳表**的结构。

B+树有两个头指针。指向根节点的指针可以进行**树的随机查找**，指向最小key的指针可以进行**链表的顺序查找**。



## B*树

跟B+树的区别只有**分裂**与**合并**。

- 分裂：在节点key过多时，并不马上分裂，而是先将一些记录分给相邻的兄弟节点。如果兄弟节点也满了，就将这2个节点分裂成3个。
- 合并：当一个节点key不足时，就将它与2个兄弟节点合并，3个变2个。

这样的改动，目的是使每一个节点内维持较多的key，提高节点存储密度，提高检索效率。



## 2-3-4树

4阶B树

每个节点至少2个至多4个子节点，也就是每个节点有2或3或4个子节点



# 参考视频

[数据结构与算法(Java语言版)](https://www.bilibili.com/video/BV11A411j7zQ?p=1)

