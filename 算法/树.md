# 基本概念

- 深度：从根节点到叶节点的node数量，根节点的深度是1 （二叉树第n层深度有2^n-1^个节点）
- 高度：从叶节点到跟节点的edge数量，叶节点的高度是0
- 注意有相同深度的节点，他们的高度不一定相同，分取决于他们自己子树的深度
- 森林：由不相交的多棵树组成



# 二叉树

## 二叉搜索树

Binary search tree

BST的中序遍历是有序的

如果左子树不为空，左子树的所有节点值都小于根节点值

如果右子树不为空，右子树的所有节点值都大于根节点值



## AVL树

**平衡二叉树**

AVL树中任意节点的左右子树高度相差只能是-1或0或1

有四种平衡调整：LL, RR, LR, RL

由于过于严格，实际操作中会浪费系统资源来反复平衡树，一般不用。



## 红黑树

**非严格平衡二叉树**

每次插入新节点都标为红色

变换规则的图像拆解见算法导论



红黑树规则

1. 每一个节点不是黑就是红
2. 红色节点不能相连
3. 根节点都是黑色（叶节点也都是黑色，不过这层叶节点有时候不画出来）
4. 红节点的两个子节点都是黑色



变换规则

1. 变色
   - 条件：当前节点红色，父节点叔节点红色
   - 操作：父节点叔节点变黑，祖父节点变红，**把指针指向祖父节点**（以祖父节点作为当前节点继续检查是否符合红黑树规则）
2. 左旋
   - 条件：当前节点红色，父节点红色，叔节点黑色，当前节点是**右子树**
   - 操作：父节点为根左旋，**把指针指向左子节点**（左旋之前是父节点）
3. 右旋
   - 条件：当前节点红色，父节点红色，叔节点黑色，当前节点是**左子树**
   - 操作：父节点变黑，祖父节点变红，祖父节点为根右旋



局限：

- 红黑树适合应用在内存中（比如HashMap，嵌入式），内存的高速可以支撑红黑树的深度。
- 由于二叉树过深的深度，在大数据上红黑树效率过低。
- 因为IO浪费与读取资源浪费（具体的解释看算法导论B树和计算机组成原理），红黑树也不适合磁盘存储。



## 伸展树

Splay tree

在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方，目的是提升高频节点的查询速度。





## 哈夫曼树

**最优二叉树**，前缀树，Huffman tree



定义：

- 节点的带权路径长度（weighted path length）：节点权 * 节点到根的路径长度
- 树的带权路径长度：**叶节点**带权路径长度之和
- 给定一些有权的节点，组成带权路径长度最小的二叉树就是**最优二叉树**或**哈弗曼树**



构建规则：

1. 构造一个含有n课二叉树的森林，每棵树只有记录权值的根节点，没有子节点
2. 选出根节点权值最小的两棵树，左小右大合并，新树的根节点就是两个权值的和
3. 重复第2步直到森林只剩下一颗树（进行n-1次合并，产生n-1个新的节点，最后最优二叉树的节点数量一定是n+n-1 = 2n-1）



应用：

- 压缩（没什么用，压缩还得看zip, rar）：将ASCII字符（byte，8位）转化成为二进制。左子节点标0，右子节点标1。
- 加解密（主要用途）：
  - 任意字符的编码都不是其他编码的前缀（前缀码）。所以不等长连续编码的解码并不会产生歧义。
  - 使用不同的权重组，得到的树结构就完全不同，用不同的树来解码就会得到不同信息。
- 描述快速分类：



## 线段树

**区间更新树**，Segment tree

作用：对于在连续区间上的add或者update操作，将时间复杂度从遍历法的O(n)提升到O(logn)。原因是每一次操作的最坏情况是两条从根到叶的路径，也就是2(logn) = O(logn)

思路：使用**满二叉树**（不满就补满，如果有n个数据，就使用4n个节点），将数据放在叶节点上，上层非叶节点会记录**延迟(lazy)的update和add**操作。

关键操作：

- pushDown递归：新操作发生时，如果新操作的范围**小于**本节点范围，意味着我们不能将新操作懒在这一层，必须将之前**所有的延迟与新操作**一起向下一层分发（只向下一次）。如果新操作的范围**大于等于**本节点范围，我们就可以把新操作懒在这一层。
- pushUp递归：用下层的新sum，更新上层的sum
- 当同一个节点的延迟update和add需要被处理时，**update优先级高**，因为如果update在后，add会被update更新为0，如果add不是0，那么update一定在前。





# 多叉树

## B树

**平衡多叉树**

**m阶**B树规则：

1. 每个节点的key保持non-descending order，key就是子节点的分隔点，所以**每个节点的key比子节点少一个**
2. 每个节点**至少**有$\lceil m/2 \rceil$个子节点（除了根节点）
3. 每个节点**至多**有m个子节点
4. 所有叶节点的深度相同，即B树的高度
5. 所有叶节点没有任何key，是指向磁盘页面的指针

==B系列树的插入操作与其他树不同，是从最底层，也就是叶节点那一层插入，把底层的key向上挤。==

B树的**分支因子**取决于 key值相对于磁盘一个页面(page)的大小（一个节点通常与一个完整磁盘页一样大，目的是一次刚好能全部拿出一个页面里存的所有记录）

包含n个key的B树的最大高度: $h_{max} = 1 + log_{\lceil m/2 \rceil}((n+1)/2)$，其中$(n+1)/2$是算叶节点数量，这个式子跟计算二叉树最大高度的原理完全一样。



红黑树为什么不适合用作数据库索引？

- 数据库肯定不在内存上（Redis在吗？），用二叉树会有IO浪费和读取资源浪费，多叉树的节点可以直接取到一整个磁盘页
- 红黑树是二叉树，在处理大量数据的时候依然会深度过深，降低效率。B树是多叉树，显著降低深度。
- 但其实B树也不够好，如果有中间节点信息丢失，会导致无法访问其下层的子节点，B+树才是数据库的索引



## B+树

与B树的区别：

1. 每个节点的 key数量==子节点数量
2. 上一层的key就是其对应的子节点的最大（或最小）key的复写，所以其实叶节点层就完整地储存了所有的key
3. 数据只存在叶节点层，这一层同时也是双向链表



最适合大数据的磁盘存储，用于**MySQL索引**。

只在叶节点存记录，所有非叶节点都只是索引，丢失上层索引不会丢失底层记录，保证系统稳定性。这也意味着B+树的查找操作一定会从根节点走到叶节点（全高度），一定不会像B树一样提前结束。

所有叶节点有序，并形成双向链表（方便求连续范围的query，比如`SELECT id FROM user WHERE id < 10;`，可以使用链表从10快速找出一组记录，而不用1-10单独从树顶查询），B+树加双向链表是一个很像**跳表**的结构。

B+树有两个头指针。指向根节点的指针可以进行**树的随机查找**，指向最小key的指针可以进行**链表的顺序查找**。



## B*树

跟B+树的区别只有**分裂**与**合并**。

- 分裂：在节点key过多时，并不马上分裂，而是先将一些记录分给相邻的兄弟节点。如果兄弟节点也满了，就将这2个节点分裂成3个。
- 合并：当一个节点key不足时，就将它与2个兄弟节点合并，3个变2个。

这样的改动，目的是使每一个节点内维持较多的key，提高节点存储密度，提高检索效率。



## 2-3-4树

4阶B树

每个节点至少2个至多4个子节点，也就是每个节点有2或3或4个子节点



# 参考视频

[数据结构与算法(Java语言版)](https://www.bilibili.com/video/BV11A411j7zQ?p=1)

