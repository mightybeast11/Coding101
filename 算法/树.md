# 基本概念

- 深度：从根节点到叶节点的node数量，跟节点的深度是1 （二叉树第n层深度有2^n-1^个节点）
- 高度：从叶节点到跟节点的edge数量，叶节点的高度是0
- 森林：由不相交的多棵树组成



# 二叉搜索树

binary search tree

BST的中序遍历是有序的

如果左子树不为空，左子树的所有节点值都小于根节点值

如果右子树不为空，右子树的所有节点值都大于根节点值



# AVL树

就是平衡二叉树，左右子树高度相差绝对值1或0.

由于过于严格，实际操作中会浪费系统资源来反复平衡树，一般不用。



# 红黑树

非严格平衡二叉树

变换规则的图像拆解推荐看算法导论

- 红黑树规则
  1. 每一个节点不是黑就是红
  2. 红色节点不能相连
  3. 根节点都是黑色（叶节点也都是黑色，不过这层叶节点有时候不画出来）
  4. 红节点的两个子节点都是黑色
- 变换规则
  1. 变色
     - 条件：当前节点红色，父节点叔节点红色
     - 操作：父节点叔节点变黑，祖父节点变红，**把指针指向祖父节点**（以祖父节点作为当前节点继续检查是否符合红黑树规则）
  2. 左旋
     - 条件：当前节点红色，父节点红色，叔节点黑色，当前节点是**右子树**
     - 操作：父节点为根左旋，**把指针指向左子节点**（左旋之前是父节点）
  3. 右旋
     - 条件：当前节点红色，父节点红色，叔节点黑色，当前节点是**左子树**
     - 操作：父节点变黑，祖父节点变红，祖父节点为根右旋
- 操作：每次插入新节点都标为红色

- 局限：
  - 红黑树适合应用在内存中（比如HashMap，嵌入式），内存的高速可以支撑红黑树的深度。
  - 由于二叉树过深的深度，在大数据上红黑树效率过低。
  - 因为IO浪费与读取资源浪费（具体的解释看算法导论B树和计算机组成原理），红黑树也不适合磁盘存储。



# 伸展树

splay tree

在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方，目的是提升高频节点的查询速度。



# 234树

多叉树



# 哈夫曼树

Huffman tree，前缀树

将不同类型的object转化成为0与1组成的byte type

应用：

- 压缩：byte是空间最小的type
- 加密：使用不同的权重组，得到的树结构就完全不同，用不同的树来解码就会得到不同信息



# B树

红黑树为什么不适合用作数据库索引？

- 数据库肯定不在内存上（Redis在吗？），会有IO浪费和读取资源浪费
- 红黑树的本质仍然是二叉树，在处理大量数据的时候依然会深度过深，降低效率。B树是多叉树，显著降低深度。
- 但其实B树也不够好，如果有中间节点信息丢失，会导致无法访问其下层的子节点，B+树才是数据库的索引



M阶：M由磁盘的页面大小决定（磁盘块和页内存都是4kb，M最好保持一致，目的是一次刚好能全部拿出一个节点里存的所有数据）

==B系列树的插入操作与其他树不同，是从最底层，也就是叶节点那一层插入，把底层节点向上层挤上去。==



# B+树

最适合大数据的磁盘存储，是MySQL的索引。

只在叶节点存数据，所有非叶节点都只是索引，丢失上层索引不会丢失底层数据，保证系统稳定性。

所有叶节点有序，并形成双向链表（方便求连续范围的query，比如`SELECT id FROM user WHERE id < 10;`，可以使用链表从10快速找出一组数据，而不用1-10单独从树顶查询），B+树加双向链表是一个很像**跳表**的结构。



与B树的区别：

1. 关键字数量不一样
2. 数据只存在叶节点
3. 增加了双向链表



# 参考视频

[数据结构与算法(Java语言版)](https://www.bilibili.com/video/BV11A411j7zQ?p=1)

