# 环

**单链表**永远只可能是**一个环**，或**一个环带一个尾巴**。尾巴的末端节点就是单链表的起始**头结点**。

因为单链表的每一个node只有一个next，那么当一个node的next是之前的结点时，这个next结点已经有了自己的next，这个链表就结束，并且没有任何结点的next是null。



题：**给定一个单链表，找入环结点。**

- **HashSet**，空间O(n)：对每一个结点，如果不在set中就记入set，当重复结点被检测到时，return这个结点。如果无环，会走到null，return null。
- **快慢指针**，空间O(1)：链表起始位置为0，慢指针从位置1出发每次一步，快指针从位置2出发每次两步，当他们相遇，将快指针移回位置0，两个指针都一次走一步，他们就会在入环结点相遇，return这个结点。如果无环，在loop的时候快指针会走到null，然后return null即可。



题：**给定两个可能有环也可能无环的单链表，检查是否相交。如果相交，返回第一个相交结点。** 时间O(n)，空间O(1)

不能考虑结点存的数值，要考虑结点的内存地址来确认他们是否是同一个。

使用上面的方法确定两个链表是否有环，然后分三种情况讨论：

1. **两个都无环**：一定是两表合一，呈Y形。判断最后一个结点是否重合就可以判断是否相交。可以通过把较长的链表剪掉起始长度差值后，同步遍历来找出相交的第一个结点。
2. **一个有环，一个无环**：不可能相交。根据第一种情况可知，如果两表相交，之后就一直重合了，那么势必会两个都无环或有环。
3. **两个都有环**：两个链表一定共用环，但是又分3种情况。
   - 不相交：从其中一个链表的入环点出发，遍历一圈回到自己，**没有遇到**另一个链表的入环点。
   - 相同入环点：判断是否有环的时候就有了两个链表分别的入环结点地址，相同地址就是这种情况。这个情况可以直接坍缩成**两个都无环**的情况，把公共入环结点作为尾结点，环直接忽略。
   - 不同入环点：从其中一个链表的入环点出发，遍历一圈回到自己，**遇到了**另一个链表的入环点。return任意一个入环点都是对的。



题：**没有链表头结点，只有中间的一个结点node，请删除这个结点。**

解：`node.val = node.next.val; node.next = node.next.next;`

Drawback：

- 在内存中，并没有真的删除node instance，而是删除了node.next instance。只是换了val的位置。
- val可能不止是一个值，无法简单的复制过来。
- 完全无法删除最后一个结点。

结论：要删除一个结点，一定需要头结点，然后调整对应位置的指针。这个题做不到。