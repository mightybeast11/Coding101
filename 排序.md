# 总结

|      排序      |   最快   | ==平均==  |  最慢   | ==空间复杂度== |  稳定  |
| :------------: | :------: | :-------: | :-----: | :------------: | :----: |
| 交换：冒泡排序 |   O(n)   |  O(n^2^)  | O(n^2^) |      O(1)      |  稳定  |
| 交换：快速排序 | O(nlogn) | O(nlogn)  | O(n^2^) |                | 不稳定 |
| 分配：基数排序 |    -     | O(d(r+n)) |    -    |                |  稳定  |



# 交换排序

## 1. 冒泡排序（bubble sort）

目标上小下大。从下往上一轮扫描，遇到违背就交换。每一轮扫描结束，最上面的一定是最小，排除它对剩余的记录再进行一轮冒泡，直到只剩最后一个记录停止。flag可以记录一轮中有没有交换，如果没有，那么已经有序，排序提前结束。

时间：平均比较趟数是O(n)，平均比较次数就是(n-1)+(n-2)+...+3+2+1，也就是O(n^2^)。

空间：只需求 记录是否有交换的flag，所以O(1)。

只有相邻记录比较与交换，所以稳定。

```java
public void BubbleSort(List l) {
    int i, j, flag;
    for (i = 0; i < l.length()-1; i++) { // (n-1) rounds of scan
    	flag = 0;
        for (j = l.length()-1; j > i; j--) { // scan from last element to i-1
            if (l[j] < l[j-1]) {
            	flag = 1;
                int temp = l[j];
                l[j] = l[j-1];
                l[j-1] = temp;
            }
        }
        if (flag == 0) break;
    }
}
```



## 2. 快速排序（quick sort）

时间：**先分组再递归**。每层都要遍历分组，每层O(n)。每层基准值(pivot)随机选，正常情况就是一共logn层。所以平均O(nlogn)。



# 分配排序

## 1. 桶排序（bucket sort）

依次把条件符合k的记录装入第k桶，然后按照k进行连接。（可以升序，也可以降序）

排序过程并不比较key值。

不是一个一个的排序，而是一桶一桶。所以只适合寻找**一批**记录。

## 2. 基数排序（radix sort）

基本见不到，坑