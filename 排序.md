# 总结

|      排序      |   最快   | ==平均==  |  最慢   | ==空间复杂度== |  稳定  |
| :------------: | :------: | :-------: | :-----: | :------------: | :----: |
| 交换：冒泡排序 |   O(n)   |  O(n^2^)  | O(n^2^) |      O(1)      |  稳定  |
| 交换：快速排序 | O(nlogn) | O(nlogn)  | O(n^2^) |                | 不稳定 |
| 分配：基数排序 |    -     | O(d(r+n)) |    -    |                |  稳定  |



# 交换排序

## 1. 冒泡排序（bubble sort）

目标上小下大。从下往上一轮扫描，遇到违背就交换。每一轮扫描结束，最上面的一定是最小，排除它对剩余的记录再进行一轮冒泡，直到只剩最后一个记录停止。

时间：平均比较趟数是O(n)，平均比较次数就是(n-1)+(n-2)+...+3+2+1，也就是O(n^2^)。

空间只需求 记录是否有交换的flag，所以O(1)。

只有相邻记录比较与交换，所以稳定。

## 2. 快速排序（quick sort）

**先分组再递归**。每层都要遍历分组，每层O(n)。每层基准值(pivot)随机选，正常情况就是一共logn层。所以平均时间复杂度O(nlogn)。



# 分配排序

## 1. 桶排序（bucket sort）

依次把条件符合k的记录装入第k桶，然后按照k进行连接。（可以升序，也可以降序）

排序过程并不比较key值。

不是一个一个的排序，而是一桶一桶。所以只适合寻找**一批**记录。

## 2. 基数排序（radix sort）

基本见不到，坑