# 总结

以下全部是**内部排序**，内部排序就是使用本地内存的排序方法。

而如果待排序的记录数量过大，就要使用外部排序方法（需要访问外部存储）。

| 排序                                                         |   最快   | ==平均==  |  最慢   | ==空间复杂度== |  稳定  |
| :----------------------------------------------------------- | :------: | :-------: | :-----: | :------------: | :----: |
| 1.1 [直接插入排序](#1.1-直接插入排序（straight-insertion-sort）) |          |           |         |                |        |
| 1.2 希尔排序                                                 |          |           |         |                |        |
| 2.1 冒泡排序                                                 |   O(n)   |  O(n^2^)  | O(n^2^) |      O(1)      |  稳定  |
| 2.2 快速排序                                                 | O(nlogn) | O(nlogn)  | O(n^2^) |    O(logn)     | 不稳定 |
| 3.1 直接选择排序                                             |          |           |         |                |        |
| 3.2 堆排序                                                   |          |           |         |                |        |
| 4. 归并排序                                                  |          |           |         |      O(n)      |  稳定  |
| 5.1 桶排序                                                   |          |           |         |                |        |
| 5.2基数排序                                                  |    -     | O(d(r+n)) |    -    |                |  稳定  |



# 1. 插入排序

## 1.1 直接插入排序（Straight insertion sort）



## 1.2 希尔排序（Shell sort / Diminishing increment sort）



# 2. 交换排序

## 2.1 冒泡排序（bubble sort）

原理：目标上小下大。从下往上一轮扫描，遇到违背就交换。每一轮扫描结束，最上面的一定是最小，排除它对剩余的记录再进行一轮冒泡，直到只剩最后一个记录停止。flag可以记录一轮中有没有交换，如果没有，那么已经有序，排序提前结束。

时间：平均比较趟数是O(n)，这个n不是length，只是大O表示里面的n。平均比较次数就是一共n项，相加得(n-1)+(n-2)+...+3+2+1，也就是O(n^2^)。

空间：只需求 记录是否有交换的flag，所以O(1)。

稳定：只有相邻记录比较与交换，所以稳定。

```java
public void bubbleSort(List l) {
    int i, j, flag;
    for (i = 0; i < l.length()-1; i++) { // (n-1) rounds of scan
    	flag = 0;
        for (j = l.length()-1; j > i; j--) { // scan from last element to i-1
            if (l[j] < l[j-1]) {
            	flag = 1;
                int temp = l[j];
                l[j] = l[j-1];
                l[j-1] = temp;
            }
        }
        if (flag == 0) break;
    }
}
```



## 2.2 快速排序（Quick sort）

原理：

- 根据一个基准点(pivot)进行分组，比基准小放左边，比基准大放右边，然后左右两组分别再进行快排(recursion)。一般选取第一个元素作为基准，递归到每组只有一个或没有元素为止。
- 每一层的交换操作：使用双指针i=0与j=length-1从最后一个元素开始向中间查找。（记住第一个元素是基准）基准元素存储在额外的变量x中来减少交换操作。从j开始向前扫描，遇到比基准小的，就放到i的位置，然后从i+1的位置（第一次就是基准+1的位置）向后扫描，遇到比基准大的就放到j的位置，然后继续从j-1的位置向前..., 从i+1的位置向后..., 以此类推，直到i>=j结束这一层的排序。

时间：最坏情况是初始情况已经有序，此时使用快速排序的效果完全等同于冒泡排序。理想的情况是基准元素是当前未排序区间的中位数，这样一共只需进行logn次分组即可，在这logn层中其实还是要进行所有元素的比较，也就是一层比较n次，所以最快时间就是O(nlogn)。平均是1.39nlogn，还是O(nlogn)。

空间：因为递归要使用栈，所以空间复杂度由递归层数决定，也就是平均O(logn)。

稳定：涉及到远距离的交换，肯定是不稳定的。

为什么叫快速排序？这个方法的平均时间是**内部排序**中最快的。

```java
package LeetCode;

public class QuickSort {

    public static int partition(int[] a, int i, int j) {
        int x = a[i]; // 因为一直在内部排序，所以这里是a[i]不是a[0]
        while (i < j) {
            while (j > i && a[j] >= x) { // 右向左扫描
                j--;
            }
            if (j > i) {
                a[i] = a[j]; // 比基准大移去左边
                i++;
            }
            while (i < j && a[i] <= x) { // 左向右扫描
                i++;
            }
            if (i < j) {
                a[j] = a[i]; // 比基准小移去右边
                j--;
            }
        }
        a[i] = x;
        return i; // 返回基准的最终位置
    }

    public static void quickSort(int[] a, int low, int high) {
        if (low >= high)
            return;
        int pivot = partition(a, low, high);
        quickSort(a, low, pivot-1);
        quickSort(a, pivot+1, high);
    }

    public static void main(String[] args) {
        int[] a = {0,6,4,4,7,3,2,9,2,1,5};

        for (Integer i : a) {
            System.out.print(i);
        }
        System.out.println();

        quickSort(a, 0, a.length-1);
        for (Integer i : a) {
            System.out.print(i);
        }
        System.out.println();
    }
}
```

> 06447329215
> 01223445679



# 3. 选择排序

## 3.1 直接选择排序（Straight selection sort）



## 3.2 堆排序（Heap sort）



# 4. 归并排序（Merge sort）

原理：

- 分：
- 合：

时间：

空间：需要辅助暂存数组，O(n)，这是空间复杂度最高的排序。

稳定：合并的时候是进行逐个按顺序比较插入。

```java

```



TimSort是MergeSort的优化版本，具体看[这里](https://www.jianshu.com/p/892ebd063ad9).

JDK的`Arrays.sort()`（更经常用的可能是外层的`Collections.sort()`），就是使用MergeSort或者TimSort.



# 5. 分配排序

## 5.1 桶排序（Bucket sort）

依次把条件符合k的记录装入第k桶，然后按照k进行连接。（可以升序，也可以降序）

排序过程并不比较key值。

不是一个一个的排序，而是一桶一桶。所以只适合寻找**一批**记录。



## 5.2 基数排序（Radix sort）

