# HashMap

- HashMap的key和value都可以是null，但是因为key的唯一性，当然就只有一个key可以是null。Hashtable的key和value都不能是null。
- 线程不安全
  - `put()`方法可能会导致扩容，扩容的操作因为要重新设计`hash()`方法，必须构建新的map进行数据迁移，如果这时又有人call `put()`添加数据，那么迁移无法结束，扩容操作可能会进入死循环。
  - 使用keyword `synchronized`可以解决这个问题，但是会给整个map的`put()`方法上锁，太慢了。HashTable就是使用的这个方法保证线程安全，不要用。
  - ConcurrentHashMap使用分段锁来锁住一小部分map，这样来保证高效和线程安全。
- HashMap其实就是个数组，存储大量的数据需要消耗过大空间，搞不定。大数据要使用BitMap和Bloom Filter。

## Java7

- 总结：==数组+链表==
- 结构：外层结构是array，array的每一个元素是单链表，使用`h = hash(key)`方法确定将value加入`array[h]`位置的链表
- 用array的原因：使用hash值**快速定位**
- 用链表的原因：发生hash冲突时**快速插入**新值

## Java8

- 总结：==数组+链表+红黑树==

- 结构：外层结构是array，array的每一个元素是单链表或红黑树，使用`h = hash(key)`方法确定将value加入`array[h]`位置的链表

- 用array的原因：使用hash值快速定位

- 用链表的原因：发生hash冲突时快速插入新值

- 用红黑树的原因：当链表长度>8时替代链表来**提升查询速度**到O(logn)
  
  链表长度<8时仍然使用链表是因为构造树也需要资源



# 树

- **二叉树**

- **AVL树**：就是平衡二叉树，左右子树高度相差绝对值1或0. 

  由于过于严格，实际操作中会浪费系统资源来反复平衡树，一般不用。

  高度：从根节点到叶节点的edge数量，叶节点的高度是0.

- **红黑树**

  - 红黑树规则
    1. 每一个节点不是黑就是红
    2. 红色节点不能相连
    3. 根节点都是黑色（叶节点也都是黑色，不过这层叶节点有时候不画出来）
    4. 红节点的两个子节点都是黑色
  - 变换规则
    1. 变色
       - 条件：当前节点红色，父节点叔节点红色
       - 操作：父节点叔节点变黑，祖父节点变红，**把指针指向祖父节点**（以祖父节点作为当前节点继续检查是否符合红黑树规则）
    2. 左旋
       - 条件：当前节点红色，父节点红色，叔节点黑色，当前节点是**右子树**
       - 操作：父节点为根左旋，**把指针指向左子节点**（左旋之前是父节点）
    3. 右旋
       - 条件：当前节点红色，父节点红色，叔节点黑色，当前节点是**左子树**
       - 操作：父节点变黑，祖父节点变红，祖父节点为根右旋
  - 操作：每次插入新节点都标为红色

- **伸展树** (splay tree): 在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方，目的是提升高频节点的查询速度。

- **234树**：多叉树



# 运算符

- [Java运算符](https://baijiahao.baidu.com/s?id=1659125201403697638&wfr=spider&for=pc)
- [原码、反码、补码 详解](https://zhuanlan.zhihu.com/p/91967268)



# 参考视频

[数据结构与算法(Java语言版)](https://www.bilibili.com/video/BV11A411j7zQ?p=1)

